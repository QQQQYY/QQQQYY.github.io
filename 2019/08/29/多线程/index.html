<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="keywords" content="chuli, Possible'Blog"><meta name="author" content="chuli"><meta name="description" content="多线程"><meta name="copyright" content="chuli"><title>多线程 | Possible'Blog</title><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css?v=1.0.2"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-stun.png?v=1.0.2"><link rel="icon" type="image/png" sizes="16x16" href="http://img.mp.itc.cn/q_mini,c_zoom,w_640/upload/20161221/c495640d0fc24a91b9c95dc0d54b6002_th.jpeg?v=1.0.2"><script>let CONFIG = {
  back2top_animation: true,
  sidebar_offsetTop: '20px'
};
window.CONFIG = CONFIG;</script></head><body><div id="container"><header id="header" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1562160387218&amp;di=85d9f523320d10c37e527f4c152a324f&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201609%2F11%2F20160911092406_XfB2k.jpeg)"><nav class="header-nav"><div class="header-nav-inner"><div class="header-nav-menu-icon fa fa-bars"></div><div class="header-nav-search"><i class="fa fa-search"></i><span>Search</span></div><div class="header-nav-menu"><span><a href="/"><i class="fa fa-home"></i>Home</a></span><span><a href="/archives/"><i class="fa fa-folder-open"></i>Archives</a></span><span><a href="/categories/"><i class="fa fa-folder-open"></i>Categories</a></span><span><a href="/tags/"><i class="fa fa-folder-open"></i>Tags</a></span><span><a href="/about/"><i class="fa fa-folder-open"></i>About</a></span></div></div></nav><div class="header-info"><div class="header-info-inner"><div class="site-info-title">Possible'Blog</div><div class="site-info-subtitle">学习使我快乐，不学习浑身难受</div></div></div></header><main id="main"><div class="main-inner"><aside id="sidebar"><div class="sidebar-inner"><div class="sidebar-nav"><span class="sidebar-nav-toc current">Catalog</span><span class="sidebar-nav-overview">Overview</span></div><section class="sidebar-toc"><div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的创建和启动"><span class="toc-number">1.</span> <span class="toc-text">线程的创建和启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#继承Thread类创建线程类"><span class="toc-number">1.1.</span> <span class="toc-text">继承Thread类创建线程类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#注意：使用继承Thread类的方法来创建线程类时，多个线程之间无法共享线程类的实例变量。"><span class="toc-number">1.1.1.</span> <span class="toc-text">注意：使用继承Thread类的方法来创建线程类时，多个线程之间无法共享线程类的实例变量。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现Runnable接口创建线程类"><span class="toc-number">1.2.</span> <span class="toc-text">实现Runnable接口创建线程类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#注意：使用实现Runnable接口的方法来创建线程类时，多个线程之间可以共享线程类的实例变量，这是因为程序所创建的Runnable实例只是Thread的target。"><span class="toc-number">1.2.1.</span> <span class="toc-text">注意：使用实现Runnable接口的方法来创建线程类时，多个线程之间可以共享线程类的实例变量，这是因为程序所创建的Runnable实例只是Thread的target。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Callable和Funture创建线程"><span class="toc-number">1.3.</span> <span class="toc-text">使用Callable和Funture创建线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#注意：Callable接口有泛型限制，Callable接口的泛型形参类型于call-方法的返回值类型相同-而且Callable-接口是一个函数式接口，因此可以使用Lambda表达式创建Callable对象。"><span class="toc-number">1.3.1.</span> <span class="toc-text">注意：Callable接口有泛型限制，Callable接口的泛型形参类型于call()方法的返回值类型相同,而且Callable()接口是一个函数式接口，因此可以使用Lambda表达式创建Callable对象。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建线程的三种方式的对比"><span class="toc-number">1.4.</span> <span class="toc-text">创建线程的三种方式的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#鉴于上面的分析，因此一般推荐使用实现Runnable接口或Callable接口的方式来创建多线程。"><span class="toc-number">1.4.1.</span> <span class="toc-text">鉴于上面的分析，因此一般推荐使用实现Runnable接口或Callable接口的方式来创建多线程。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的生命周期"><span class="toc-number">2.</span> <span class="toc-text">线程的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#新建和就绪状态"><span class="toc-number">2.1.</span> <span class="toc-text">新建和就绪状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行和阻塞状态"><span class="toc-number">2.2.</span> <span class="toc-text">运行和阻塞状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死亡状态"><span class="toc-number">2.3.</span> <span class="toc-text">死亡状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#注意：不要对处于死亡状态的线程调用start-方法，程序只能对新建状态的线程调用start-，对象新建状态的线程两次调用start-方法也是错误的，这都会引发IllegalThreadStateException异常。"><span class="toc-number">2.3.1.</span> <span class="toc-text">注意：不要对处于死亡状态的线程调用start()方法，程序只能对新建状态的线程调用start()，对象新建状态的线程两次调用start()方法也是错误的，这都会引发IllegalThreadStateException异常。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#控制线程"><span class="toc-number">3.</span> <span class="toc-text">控制线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#join-线程"><span class="toc-number">3.1.</span> <span class="toc-text">join()线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程睡眠：sleep"><span class="toc-number">3.2.</span> <span class="toc-text">线程睡眠：sleep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改变线程的优先级"><span class="toc-number">3.3.</span> <span class="toc-text">改变线程的优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程同步"><span class="toc-number">4.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程安全问题"><span class="toc-number">4.1.</span> <span class="toc-text">线程安全问题</span></a></li></ol></li></ol></div></section><section class="hide sidebar-overview"><div class="sidebar-author"><img class="sidebar-author-avatar" src="http://img.mp.itc.cn/q_mini,c_zoom,w_640/upload/20161221/c495640d0fc24a91b9c95dc0d54b6002_th.jpeg" alt="avatar"></div><div class="sidebar-state"><div class="sidebar-state-item sidebar-state-posts"><a href="/archives/"><div class="sidebar-state-item-count">17</div><div class="sidebar-state-item-name">Articles</div></a></div><div class="sidebar-state-item sidebar-state-categories"><a href="/categories/"><div class="sidebar-state-item-count">0</div><div class="sidebar-state-item-name">Categories</div></a></div><div class="sidebar-state-item sidebar-state-tags"><a href="/tags/"><div class="sidebar-state-item-count">0</div><div class="sidebar-state-item-name">Tags</div></a></div></div><div class="sidebar-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="creative commons"></a></div></section><div class="sidebar-progress"><div class="sidebar-progress-read"><span>You have read</span><span class="sidebar-progress-number"></span></div><div class="sidebar-progress-line"></div></div></div></aside><div class="main-content code-highlight"><div class="post-header"><h1 class="post-title">多线程</h1><div class="post-meta"><span class="post-meta-create"><i class="fa fa-calendar-o"></i><span>Posted </span><span>2019-08-29</span></span><span class="post-meta-update"><i class="fa fa-calendar-check-o"></i><span>updated </span><span>2019-09-08</span></span><span class="post-meta-reading-count"><i class="fa fa-eye"></i><span>Visited </span><span id="busuanzi_value_page_pv"></span></span></div></div><div class="post-body"><h2 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h2><p>Java使用<code>Thread</code>类代表线程，所有的线程对象都必须是<code>Thread</code>类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流（一段顺序执行的代码）。Java使用线程执行体来代表这段程序流。</p>
<h3 id="继承Thread类创建线程类"><a href="#继承Thread类创建线程类" class="headerlink" title="继承Thread类创建线程类"></a>继承<code>Thread</code>类创建线程类</h3><p>通过继承<code>Thread</code>来创建和启动多线程的步骤如下：</p>
<blockquote>
<ul>
<li>定义<code>Thread</code>类的子类，并重写该类的run()方法，该<code>run()</code>方法的方法体就是线程需要完成的任务。因此<code>run()</code>方法称为线程执行体。</li>
<li>创建<code>Thread</code>子类的实例，即创建了线程对象。</li>
<li>调用线程对象的<code>start()</code>方法来启动该线程。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">//重写run()方法，run()方法的方法体就是线程执行体</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			<span class="comment">//当线程体继承法Thread时，直接使用this即可获取当前线程</span></span><br><span class="line">			<span class="comment">//Thread对象的getName()返回当前线程的名字</span></span><br><span class="line">			<span class="comment">//因此直接调用getName()方法返回当前线程名字</span></span><br><span class="line">			System.out.println(getName() + <span class="string">" "</span> +i );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			<span class="comment">//调用Thread的currentThread()方法获取当前线程</span></span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="comment">//创建并启动第一个线程</span></span><br><span class="line">				<span class="keyword">new</span> FirstThread().start();</span><br><span class="line">                <span class="comment">//创建并启动第二个线程</span></span><br><span class="line">				<span class="keyword">new</span> FirstThread().start();</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意：使用继承Thread类的方法来创建线程类时，多个线程之间无法共享线程类的实例变量。"><a href="#注意：使用继承Thread类的方法来创建线程类时，多个线程之间无法共享线程类的实例变量。" class="headerlink" title="注意：使用继承Thread类的方法来创建线程类时，多个线程之间无法共享线程类的实例变量。"></a>注意：使用继承Thread类的方法来创建线程类时，多个线程之间无法共享线程类的实例变量。</h4><h3 id="实现Runnable接口创建线程类"><a href="#实现Runnable接口创建线程类" class="headerlink" title="实现Runnable接口创建线程类"></a>实现Runnable接口创建线程类</h3><p>实现<code>Runnable</code>接口来创建并启动多线程的步骤如下：</p>
<blockquote>
<ul>
<li>定义<code>Runnable</code>接口的实现类，并重写该接口的<code>run()</code>，该<code>run()</code>方法的方法体同样是该线程的执行体。</li>
<li>创建<code>Runnable</code>实现类的实例，并以此实例作为<code>Thread</code>的<code>target</code>来创建<code>Thread</code>对象，该<code>Thread</code>对象才是真正的线程对象。代码如下：</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Runnable实现类的对象</span></span><br><span class="line"><span class="keyword">var</span> st=<span class="keyword">new</span> SecondThread();</span><br><span class="line"><span class="comment">//以Runnable实现类的对象作为Thread的Target来创建Thread对象，即线程对象</span></span><br><span class="line"><span class="keyword">new</span> Thread(st);</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>调用线程对象的start()方法来启动该线程。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">//run()方法同样是线程执行体</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			<span class="comment">//当线程类实现Runnable接口时</span></span><br><span class="line">			<span class="comment">//如果想要获取当前线程，只能使用Thread.currentThread()方法</span></span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" "</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> +i);</span><br><span class="line">			<span class="keyword">if</span>( i==<span class="number">20</span> ) &#123;</span><br><span class="line">				<span class="keyword">var</span> st=<span class="keyword">new</span> SecondThread();</span><br><span class="line">				<span class="comment">//通过new Thread(target,name)方法来创建新线程</span></span><br><span class="line">				<span class="keyword">new</span> Thread(st,<span class="string">"新线程1"</span>).start();</span><br><span class="line">				<span class="keyword">new</span> Thread(st,<span class="string">"新线程2"</span>).start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意：使用实现Runnable接口的方法来创建线程类时，多个线程之间可以共享线程类的实例变量，这是因为程序所创建的Runnable实例只是Thread的target。"><a href="#注意：使用实现Runnable接口的方法来创建线程类时，多个线程之间可以共享线程类的实例变量，这是因为程序所创建的Runnable实例只是Thread的target。" class="headerlink" title="注意：使用实现Runnable接口的方法来创建线程类时，多个线程之间可以共享线程类的实例变量，这是因为程序所创建的Runnable实例只是Thread的target。"></a>注意：使用实现Runnable接口的方法来创建线程类时，多个线程之间可以共享线程类的实例变量，这是因为程序所创建的Runnable实例只是Thread的target。</h4><h3 id="使用Callable和Funture创建线程"><a href="#使用Callable和Funture创建线程" class="headerlink" title="使用Callable和Funture创建线程"></a>使用Callable和Funture创建线程</h3><ul>
<li>前面已经指出，通过实现<code>Runnable</code>接口创建多线程时，<code>Thread</code>类的作用就是把<code>run()</code>方法包装成线程执行体，那么是否可以直接把任意方法都包装成线程执行体呢？<code>Java</code>目前不行！但是Java模仿者C#可以（C#可以把任意方法包装成线程执行体，包括有返回值的方法）。</li>
<li>也许受此启发，从Java5开始，<code>Java</code>提供<code>Callable</code>接口，该方法怎么看都像是<code>Runnable</code>接口的加强版，<code>Callable</code>接口提供了一个<code>call()</code>方法可以作为线程执行体，但<code>call()</code>方法比<code>run()</code>方法功能更强大。</li>
<li><code>call()</code>方法可以有返回值。</li>
<li><code>call()</code>可以声明抛出异常。</li>
<li><code>Java5</code>提供了<code>Fucture</code>接口来代表<code>Callable</code>接口里<code>call()</code>方法的返回值，并为<code>Future</code>接口提供了一个<code>FutureTaskTask</code>实现类，该实现类实现<code>Functure</code>接口，并实现<code>Runnable()</code>接口–可以作为<code>Thread</code>的<code>target</code>。</li>
<li>在Fucture接口中提供了如下几个公共方法来控制它关联的Callable任务。<ul>
<li>boolean cancel(boolean mayInterruptIfRunning)：试图取消该Future里关联的Callable任务。</li>
<li>V get()：返回Callable任务里call()方法的返回值。调用该方法将导致线程阻塞，必须等到子线程结束后才会得到返回值。</li>
<li>V get(long timeout, TimeUnit unit)：返回Callable任务里call()方法的返回值。该方法让程序最多阻塞timeout和unit指定的时间，如果经过指定的时间Callable任务依然没有返回值，将会抛出TimeoutException异常。</li>
<li>boolean isCancelled()：如果此任务在正常完成之前取消，则返回 true 。 </li>
<li>boolean isDone()：如果Callable任务已完成，则返回true</li>
</ul>
</li>
<li>创建并启动有返回值的线程如下：<blockquote>
<ul>
<li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程的执行体，且该call()方法有返回值，再创建Callable实现类的实例。从Java8开始，可以使用Lambda表达式创建Callable对象</li>
<li>使用FutureTask类来包装Callable对象，该FutureTask对象包装了该Callable对象的call()方法的返回值。</li>
<li>使用FutureTask对象作为Thread的target来创建并启动多线程</li>
<li>调用FutureTask对象的get()方法来获取子线程执行结束后的返回值。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建Callable对象</span></span><br><span class="line">		<span class="keyword">var</span> st=<span class="keyword">new</span> ThirdThread();</span><br><span class="line">		<span class="comment">//先使用Lambda表达式创建Callable&lt;Integer&gt;对象</span></span><br><span class="line">		FutureTask&lt;Integer&gt; task=<span class="keyword">new</span> FutureTask&lt;Integer&gt;((Callable&lt;Integer&gt;)() -&gt; &#123;</span><br><span class="line">			<span class="comment">//var只能用于带有构造器的局部变量</span></span><br><span class="line">			<span class="comment">//除了局部变量，for循环是唯一可以使用 var的地方</span></span><br><span class="line">			<span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">"的循环变量i的值："</span> + i);</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//call()方法可以有返回值</span></span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;) ;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"的循环变量i的值："</span> + i);</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">20</span>) &#123;</span><br><span class="line">				<span class="comment">//实质还是以Callable对象来创建并启动线程的</span></span><br><span class="line">				<span class="keyword">new</span> Thread(task,<span class="string">"有返回值的线程"</span>).start();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//获取子线程的返回值</span></span><br><span class="line">			System.out.println(<span class="string">"子线程的返回值："</span> + task.get());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="注意：Callable接口有泛型限制，Callable接口的泛型形参类型于call-方法的返回值类型相同-而且Callable-接口是一个函数式接口，因此可以使用Lambda表达式创建Callable对象。"><a href="#注意：Callable接口有泛型限制，Callable接口的泛型形参类型于call-方法的返回值类型相同-而且Callable-接口是一个函数式接口，因此可以使用Lambda表达式创建Callable对象。" class="headerlink" title="注意：Callable接口有泛型限制，Callable接口的泛型形参类型于call()方法的返回值类型相同,而且Callable()接口是一个函数式接口，因此可以使用Lambda表达式创建Callable对象。"></a>注意：Callable接口有泛型限制，Callable接口的泛型形参类型于call()方法的返回值类型相同,而且Callable()接口是一个函数式接口，因此可以使用Lambda表达式创建Callable对象。</h4><h3 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h3><p>采用实现Runnable、Callable接口的方式创建多线程的优缺点</p>
<blockquote>
<ul>
<li>线程类只是实现了Runnable接口或Callable接口，还可以继承其它的类。</li>
<li>在这种方式下，多个线程中可以共享同一个Target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而将CPU、代码和数据分开，形成清晰的模式，较好的体现了面向对象的思想。</li>
<li>劣势是，编程稍稍复杂，如果需要访问当前线程，必须使用Thread.cuurentThread()方法。<br>采用继承Thread类的方式创建多线程的优缺点</li>
<li>劣势是，因为线程类已经继承了Thread类，所以不能再继承其它类。</li>
<li>优势是，编写简单，如果需要访问当前的线程，则无需使用Thread.currentThread()方法，直接使用this即可获取当前线程。</li>
</ul>
</blockquote>
<h4 id="鉴于上面的分析，因此一般推荐使用实现Runnable接口或Callable接口的方式来创建多线程。"><a href="#鉴于上面的分析，因此一般推荐使用实现Runnable接口或Callable接口的方式来创建多线程。" class="headerlink" title="鉴于上面的分析，因此一般推荐使用实现Runnable接口或Callable接口的方式来创建多线程。"></a>鉴于上面的分析，因此一般推荐使用实现Runnable接口或Callable接口的方式来创建多线程。</h4><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中，它要经过新建（new）、就绪（Ready）、运行（Running）、阻塞（Blocked）和死亡（Dead）5中状态。尤其是当线程启动以后，它不可能一直“霸占”者CPU独自运行，所以CPU需要在多个线程之间切换，于是线程状态也会多次在运行、就绪之间切换。</p>
<h3 id="新建和就绪状态"><a href="#新建和就绪状态" class="headerlink" title="新建和就绪状态"></a>新建和就绪状态</h3><blockquote>
<ul>
<li>当线程使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其它的Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序此时也不会执行线程的线程执行体。</li>
<li>当线程对象调用了start()方法之后，该线程就处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始执行，只是表示该线程可以执行了。至于改写该线程开始何时，取决于JVM里线程调度器调度。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeRun</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">//重写run()方法，run()方法的方法体就是线程的执行体</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			<span class="comment">//当线程体继承法Thread时，直接使用this即可获取当前线程</span></span><br><span class="line">			<span class="comment">//Thread对象的getName()返回当前线程的名字</span></span><br><span class="line">			<span class="comment">//因此直接调用getName()方法返回当前线程名字</span></span><br><span class="line">			System.out.println(getName() + <span class="string">" "</span> +i );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			<span class="comment">//调用Thread的currentThread()方法获取当前线程</span></span><br><span class="line">			System.out.println(Thread.currentThread().getName()+ <span class="string">" "</span>+i);</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">20</span>) &#123;</span><br><span class="line">				<span class="comment">//直接调用线程对象的run()方法</span></span><br><span class="line">				<span class="keyword">new</span> FirstThread().run();</span><br><span class="line">				<span class="keyword">new</span> FirstThread().run();</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行和阻塞状态"><a href="#运行和阻塞状态" class="headerlink" title="运行和阻塞状态"></a>运行和阻塞状态</h3><blockquote>
<ul>
<li>如果处于就绪状态的线程获得cpu，开始执行run()方法的线程执行体，则该线程处于运行状态，如果计算机只有一个cpu，那个在任何时刻只有一个线程处于运行状态。当然，在一个多处理器的机器上，将会有多个线程并行执行。当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的线程。</li>
<li>抢占式的调用策略：被动式释放资源。</li>
<li>协作式的调度策略：主动式释放资源。</li>
<li>当发生如下情况时，线程将会进行阻塞状态。<blockquote>
<ul>
<li>线程调用sleep()方法主动放弃所占用的处理器资源。</li>
<li>线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。</li>
<li>线程试图获得一个同步监听器，但该同步监听器正被其它线程所持有。</li>
<li>线程在等待某个通知（notify）</li>
<li>线程调用了线程的suspend()方法将该线程挂起。但是这个方法容易导致死锁，所以应该尽量避免使用该方法。</li>
</ul>
</blockquote>
</li>
<li>针对上面几种情况，当发生如下特定情况时可以接触上面的阻塞，让该线程重新进入就绪状态。<blockquote>
<ul>
<li>调用了sleep()方法的线程经过了指定时间。</li>
<li>线程调用的阻塞式IO方法已返回。</li>
<li>线程成功获得了试图获取的同步监听器。</li>
<li>线程正在等待某个通知时，其它的线程发出了一个通知。 </li>
<li>处于挂起状态的线程被调用了resume()恢复方法。</li>
</ul>
</blockquote>
</li>
<li>yield()方法可以让线程从运行状态进入就绪状态。</li>
</ul>
</blockquote>
<h3 id="死亡状态"><a href="#死亡状态" class="headerlink" title="死亡状态"></a>死亡状态</h3><blockquote>
<ul>
<li>线程会以如下三种方式结束，结束后就处于死亡状态。<blockquote>
<ul>
<li>run()或call()方法执行完成，线程正常结束</li>
<li>线程抛出一个未捕获的Exception或Error</li>
<li>直接调用该线程的stop()方法来结束该线程–该方法容易导致死锁，通常不推荐使用。</li>
</ul>
</blockquote>
</li>
<li>isAlive()：用于测试某个线程是否已经死亡，当线程处于就绪、运行、阻塞三种状态时，该方法返回true,当线程处于新建、死亡两种状态时，该方法返回false。</li>
</ul>
</blockquote>
<h4 id="注意：不要对处于死亡状态的线程调用start-方法，程序只能对新建状态的线程调用start-，对象新建状态的线程两次调用start-方法也是错误的，这都会引发IllegalThreadStateException异常。"><a href="#注意：不要对处于死亡状态的线程调用start-方法，程序只能对新建状态的线程调用start-，对象新建状态的线程两次调用start-方法也是错误的，这都会引发IllegalThreadStateException异常。" class="headerlink" title="注意：不要对处于死亡状态的线程调用start()方法，程序只能对新建状态的线程调用start()，对象新建状态的线程两次调用start()方法也是错误的，这都会引发IllegalThreadStateException异常。"></a>注意：不要对处于死亡状态的线程调用start()方法，程序只能对新建状态的线程调用start()，对象新建状态的线程两次调用start()方法也是错误的，这都会引发IllegalThreadStateException异常。</h4><h2 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h2><h3 id="join-线程"><a href="#join-线程" class="headerlink" title="join()线程"></a><code>join()</code>线程</h3><blockquote>
<ul>
<li><code>Thread</code>提供了让一个线程等待另一个完成的方法–&gt;<code>join()</code>,当某个程序执行流中调用其它线程的<code>join()</code>，调用线程将被阻塞，直到被<code>join()</code>方法加入的<code>join</code>线程执行完为止。</li>
<li>join()方法通常由使用线程的程序调用，以将大问题划分成许多小问题，每个小问题分配一个线程，当所有的小问题处理完成后，再调用主线程来进一步操作。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JoinThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写run()方法，定义线程执行体</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">//启动子线程</span></span><br><span class="line">		<span class="keyword">new</span> JoinThread(<span class="string">"新线程"</span>).start();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">20</span>) &#123;</span><br><span class="line">				<span class="keyword">var</span> jt=<span class="keyword">new</span> JoinThread(<span class="string">"被Join的线程"</span>);</span><br><span class="line">				jt.start();</span><br><span class="line">				<span class="comment">//main线程调用了jt线程的join()，main()线程必须等待jt执行完成才会向下执行</span></span><br><span class="line">				jt.join();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```			</span><br><span class="line">&gt;* join()方法有如下三种重载形式：</span><br><span class="line">&gt;&gt;* join()：等待被join()的线程执行完成。</span><br><span class="line">&gt;&gt;* join(<span class="keyword">long</span> millis)：等待被join的线程的时间最长为mills毫秒。如果在millis毫秒内被join的线程还没执行完成，则不再等待。</span><br><span class="line">&gt;&gt;* join(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanos)：等待被join的线程的时长最长为millis毫秒加nanos毫微秒。</span><br><span class="line">### 后台线程</span><br><span class="line">&gt;* 后台线程是在后台线程运行的，它的任务是为其它线程提供服务，又称为“守护线程”或“精灵线程”。</span><br><span class="line">&gt;* 后台线程有个特征：如果所有的前台线程都死亡，后台线程会自动死亡。</span><br><span class="line">&gt;* 调用Thread对象的setDaemon(<span class="keyword">true</span>)可以将指定的线程设置为后台线程，且该方法的调用必须在线程启动之前，否则会抛出IllegalThreadStateException。</span><br><span class="line">&gt;* Thread类还提供了一个isDaemon()，判断线程是否为后台线程。</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义后台线程的线程执行体与普通线程没有任何区别</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++) &#123;</span><br><span class="line">			System.out.println(getName()+ <span class="string">" "</span>+ i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> t=<span class="keyword">new</span> DaemonThread();</span><br><span class="line">		<span class="comment">//将此线程设置成后台线程</span></span><br><span class="line">		t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		<span class="comment">//启动后台线程</span></span><br><span class="line">		t.start();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" "</span>+i);</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="comment">//  ----- 线程执行到此处，前台线程（main线程）结束 -----</span></span><br><span class="line">		<span class="comment">// 后台线程也应该执行结束</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程睡眠：sleep"><a href="#线程睡眠：sleep" class="headerlink" title="线程睡眠：sleep"></a>线程睡眠：sleep</h3><blockquote>
<ul>
<li>如果需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用Thread的静态方法sleep()方法来实现。sleep()方法有两种重载方式;<blockquote>
<ul>
<li>static void sleep(int millis)：让当前正在执行的线程暂停millis毫秒，并进入阻塞状态，该方法受到计时器和线程调度其的精度与准确度的影响。</li>
<li>static void sleep(int millis,int nanos)：让当前正在执行的线程暂停millis毫秒加nanos毫微秒，并进入阻塞状态，该方法受到计时器和线程调度其的精度与准确度的影响。</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li>当当前线程调用sleep()方法进入阻塞状态后，在其睡眠时间段内，该线程不会获得执行机会，即使系统中没有其它可以执行的线程，处于sleep()中的线程也不会执行，因此sleep()方法常用来暂停线程的执行。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * sleep()：用来使一个正在执行的线程暂停一段时间，并进入阻塞状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 朱楚利</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">60</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"当前时间："</span>+<span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()) );</span><br><span class="line">			<span class="comment">//调用sleep()方法让当前线程暂停1s</span></span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>关于sleep()方法和yield()方法的区别<blockquote>
<ul>
<li>sleep()方法暂停当当前线程后，会给其它线程执行机会，不会理会其它线程的优先级；但yield()方法只会给优先级相同，或优先级更高的线程获得执行的机会。</li>
<li>sleep()方法会将线程进入阻塞状态，直到经过阻塞时间才会进入就绪状态；而yield()不会将线程进入阻塞状态，它只会强制当前线程进入就绪状态。因此完全有可能某个线程被yield()方法暂停之后，立即再次获得处理器资源被执行。</li>
<li>sleep()方法声明抛出了InterruptedException，所以调用sleep()方法时要么捕获该异常，要么显示声明出该异常；而yield()方法则没有声明抛出任何异常。</li>
<li>sleep()方法比yield()方法有更好的移植性，通常不建议使用yield()方法来控制并发线程的执行。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="改变线程的优先级"><a href="#改变线程的优先级" class="headerlink" title="改变线程的优先级"></a>改变线程的优先级</h3><blockquote>
<ul>
<li>每个线程执行时都具有一定的优先级，优先级高的线程获得较多的执行机会，而优先级低的线程则获得较少的执行机会。</li>
<li>每个线程默认的优先级都与创建它的父线程的优先级相同，在默认的情况下，main线程具有普通的优先级，由main线程创建的子线程也有普通普通优先级。</li>
<li>Thread类提供了setPriority(int newPriority)、getPriority()方法来设置和返回指定线程的优先级，其中setPriority()方法的参数可以是一个整数，范围是1-10之间，也可以使用Thread类的如下三个静态常量。<blockquote>
<ul>
<li>MAX_PRIORITY：其值是10。</li>
<li>MIN_PRIORITY：其值是1。</li>
<li>NORM_PRIORITY：其值是5。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 线程的优先级</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 朱楚利</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个有参数的构造器，用于创建线程时指定name</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PriorityTest</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++) &#123;</span><br><span class="line">			System.out.println(getName() + <span class="string">"，其优先级是："</span>+getPriority()+<span class="string">"，循环变量的值："</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//改变主线程的优先级</span></span><br><span class="line">		Thread.currentThread().setPriority(<span class="number">6</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">10</span>) &#123;</span><br><span class="line">				<span class="keyword">var</span> low=<span class="keyword">new</span> PriorityTest(<span class="string">"低级"</span>);</span><br><span class="line">				low.start();</span><br><span class="line">				System.out.println(<span class="string">"创建之初的优先级："</span>+low.getPriority());</span><br><span class="line">				<span class="comment">//设置线程的优先级为最低级</span></span><br><span class="line">				low.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">20</span>) &#123;</span><br><span class="line">				<span class="keyword">var</span> high=<span class="keyword">new</span> PriorityTest(<span class="string">"高级"</span>);</span><br><span class="line">				high.start();</span><br><span class="line">				System.out.println(<span class="string">"创建之初线程的优先级："</span>+high.getPriority());</span><br><span class="line">				<span class="comment">//设置线程的优先级为最高级</span></span><br><span class="line">				high.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<blockquote>
<ul>
<li>运行结果为</li>
</ul>
</blockquote>
</blockquote>
<p><img src="img/%E6%8D%95%E8%8E%B7.PNG" alt="avavtor.png"></p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>关于线程安全问题，有一个经典的问题—-银行取钱问题。银行取钱的基本流程可以分为如下几个步骤：</p>
<blockquote>
<blockquote>
<ul>
<li>用户输入账号、密码，系统判断用户的账号、密码是否正确。</li>
<li>用户输入取款金额 。</li>
<li>系统判断账户余额是否大于取款金额 。</li>
<li>如果是，则取款成功，如果不是，则取款失败。</li>
<li>下面定义两个线程 模拟两个人使用同一个账号并发取钱的问题。</li>
</ul>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-footer-end"><span>------</span><span>End of text, thank you for reading</span><span>------</span></div><div class="post-footer-copyright"><div class="copyright-author"><span class="copyright-name">Author:</span><span class="copyright-value"><a href="http://qqqqyy.github.io">chuli</a></span></div><div class="copyright-link"><span class="copyright-name">Link:</span><span class="copyright-value"><a href="http://qqqqyy.github.io/2019/08/29/多线程/">http://qqqqyy.github.io/2019/08/29/多线程/</a></span></div><div class="copyright-notice"><span class="copyright-name">Copyright:</span><span class="copyright-value">All articles in this blog are licensed under  <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> unless stating additionally</span></div></div><nav id="paginator"><div class="post-paginator"><div class="article-prev pull-left"><a href="/2019/09/08/注解与反射/"><i class="fa fa-chevron-left"></i><span class="title">注解与反射</span></a></div><div class="article-next pull-right"><a href="/2019/08/16/手写Web服务器/"><span class="title">手写Web服务器</span><i class="fa fa-chevron-right"></i></a></div></div></nav></footer></div></div></main><footer id="footer"><div class="footer-inner"><div><span>&copy; 2019</span><span class="fa fa-heart heart-beat footer-separator" style="color: #ff0000"></span><span>chuli.</span></div><div><span class="footer-powered">Powered by <a href="http://hexo.io/" title="hexo" target="_blank" rel="noopener">hexo</a></span><span> v3.9.0.</span><span class="footer-separator">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="stun" target="_blank" rel="noopener">stun</a></span><span> v1.0.2.</span></div><div class="busuanzi"><script async src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@2.3/bsz.pure.mini.js"></script><span class="busuanzi-uv"><i class="fa fa-user"></i><span>Visitors </span><span id="busuanzi_value_site_uv"></span></span><span class="separator">|</span><span class="busuanzi-pv"><i class="fa fa-eye"></i><span>Views </span><span id="busuanzi_value_site_pv"></span></span></div></div></footer><div id="back-top"><div class="back-top-inner" title="Back to top"><i class="fa fa-rocket"></i></div></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="/js/utils.js?v=1.0.2"></script><script src="/js/scroll.js?v=1.0.2"></script><script src="/js/header.js?v=1.0.2"></script><script src="/js/sidebar.js?v=1.0.2"></script><script src="/js/post.js?v=1.0.2"></script></body></html>